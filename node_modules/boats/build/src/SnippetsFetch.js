"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
require("colors");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const upath_1 = tslib_1.__importDefault(require("upath"));
const CachePaths_1 = require("./constants/CachePaths");
const commandRun_1 = tslib_1.__importDefault(require("./utils/commandRun"));
const camelCaseStringReplacement_1 = tslib_1.__importDefault(require("./utils/camelCaseStringReplacement"));
class SnippetsFetch {
    /**
     * Returns the folder to store the git repos in
     */
    getCacheFolder() {
        this.targetGitCacheDir = upath_1.default.join(process.cwd(), CachePaths_1.GIT_DIRECTORY_SNIPPET_CACHE);
        return this.targetGitCacheDir;
    }
    /**
     * Generates a cache directory relative to the url given
     */
    calculateLocalDirectoryFromUrl(url) {
        const camelCaseUrl = camelCaseStringReplacement_1.default(url, ['/', ':', '.', '-', '?', '#']);
        return upath_1.default.join(this.getCacheFolder(), camelCaseUrl);
    }
    /**
     * Deletes the entire cache directory
     */
    cleanSingleCacheDir(cachePath) {
        if (!cachePath.includes(this.targetGitCacheDir)) {
            console.error('For safety all folder removals must live within node_modules of this package.');
            console.error('An incorrect cache folder path has been calculated, aborting! Please report this as an issue on gitHub.');
            throw new Error('Aborting openapi-nodegen, see above comments.');
        }
        console.log('Removing the cacheDir: ' + cachePath);
        fs_extra_1.default.removeSync(cachePath);
    }
    /**
     * Throws an error if gitFetch is not installed
     * @return {Promise<boolean>}
     */
    async hasGit() {
        try {
            await commandRun_1.default('git', ['--help'], true);
            return true;
        }
        catch (e) {
            console.error('Git command not found on this operating system, please install git to continue.');
            return false;
        }
    }
    /**
     * Runs a simple cache exists on the proposed local file path
     * @param cachePath
     * @return {boolean}
     */
    gitCacheExists(cachePath) {
        console.log('Checking for existing snippet cache: ' + cachePath);
        return fs_extra_1.default.existsSync(cachePath);
    }
    /**
     * Fetches the contents of a gitFetch url to the local cache
     * @param {string} url - Url to fetch via gitFetch
     * @return {Promise<string>}
     */
    async gitFetch(url) {
        if (!await this.hasGit()) {
            throw new Error('Could not fetch cache from gitFetch url as gitFetch is not locally installed');
        }
        const cacheDirectory = this.calculateLocalDirectoryFromUrl(url);
        const urlParts = this.getUrlParts(url);
        try {
            if (this.gitCacheExists(cacheDirectory) && !urlParts.b) {
                await this.gitPull(cacheDirectory);
            }
            else {
                this.cleanSingleCacheDir(cacheDirectory);
                await this.gitClone(urlParts.url, cacheDirectory, urlParts.b);
            }
        }
        catch (e) {
            console.error('Could not clone or pull the given git repository!');
            this.cleanSingleCacheDir(cacheDirectory);
            throw e;
        }
        return cacheDirectory;
    }
    /**
     * Changes directory then pulls an expected git repo
     * @param cacheDirectory
     * @return {Promise<boolean>}
     */
    async gitPull(cacheDirectory) {
        const cwd = upath_1.default.toUnix(process.cwd());
        process.chdir(cacheDirectory);
        try {
            console.log('Updating git cache');
            await commandRun_1.default('git', ['pull']);
            process.chdir(cwd);
            return true;
        }
        catch (e) {
            process.chdir(cwd);
            throw e;
        }
    }
    /**
     * Clones a remote git url to a given local directory
     * @param url
     * @param cacheDirectory
     * @param gitBranchOrTag
     * @return {Promise<*>}
     */
    async gitClone(url, cacheDirectory, gitBranchOrTag) {
        console.log(`BOATS Snippets, clone git repository to: ${cacheDirectory}`);
        fs_extra_1.default.ensureDirSync(cacheDirectory);
        if (gitBranchOrTag) {
            await commandRun_1.default('git', ['clone', '-b', gitBranchOrTag, url, cacheDirectory]);
        }
        else {
            await commandRun_1.default('git', ['clone', url, cacheDirectory]);
        }
    }
    /**
     *
     * @param {string} url
     * @return {{b: string, url: string}}
     */
    getUrlParts(url) {
        let cloneUrl = url;
        let b;
        if (url.includes('#')) {
            const parts = url.split('#');
            cloneUrl = parts[0];
            b = parts[1];
        }
        return {
            url: cloneUrl,
            b
        };
    }
    /**
     * Returns local helpers name or full path to cached directory
     * @param {string} input - Either es6 | typescript | https github url |
     *                        local directory relative to where this package is called from
     * @return {Promise<string>} - Returns the full path on the local drive to the tpl directory.
     */
    async resolve(input) {
        if (input.substring(0, 8) === 'https://') {
            return await this.gitFetch(input);
        }
        else {
            const localSnippetPath = upath_1.default.join(process.cwd(), input);
            // check local exists
            if (!fs_extra_1.default.existsSync(localSnippetPath)) {
                throw new Error('Local snippet could not be found: ' + localSnippetPath);
            }
            return localSnippetPath;
        }
    }
}
exports.default = new SnippetsFetch();
